First we need to know which type we are facing. So, if we send this example, we are sending that we will use TE chunked, we send 3 and abc, so this is ok nothing happen. But, then we are sendin an X, which is not a chunk size, and we got an invalid request. As result we know that the front is working with chunked encoding.
![[Pasted image 20250903213053.png]]
![[Pasted image 20250903213322.png]]

Now we send another payload, where we use 0 in order to indicate that the msg has 0 character. Which bypass in some way the front, however on the back it uses CL, what trigger that the server remain waiting for the 6th character. 
![[Pasted image 20250903213526.png]]
![[Pasted image 20250903213548.png]]

Assembling the payload we need to put two parts, the second part is the GPOST that resolve the lab. We count 5 for the CL, but we need one more at least in order that the server remain waiting for the next request. On the bottom there is something interesting about the amount that we can set here.
![[Pasted image 20250903214721.png]]
![[Pasted image 20250903214953.png]]

Here we need to count how many character there is on the second part, in order to setup the first part which use TE chunked.
![[Pasted image 20250903214805.png]]

This is the final payload. One package with setup as chunked, where we put 56, the amount of character inside of the gpost. But, there is a 4 in CL, so the back count until 56. 

![[Pasted image 20250903214844.png]]

And this is the other request, to trigger the lab solution

![[Pasted image 20250903220029.png]]


Here there is something interesting,  if we count the amount of character on the normal request it will be 164, but if we add 1 more the server will remain waiting for  the next part. So we can setup the payload with more than 4 and less than 165. On top of that, we need to change the character amount on the chunk part. because we are using 2 character more to define the CLx
![[Pasted image 20250903215211.png]]